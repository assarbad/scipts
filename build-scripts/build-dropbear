#!/usr/bin/env bash
[[ -t 1 ]] && { cG="\e[1;32m"; cR="\e[1;31m"; cB="\e[1;34m"; cW="\e[1;37m"; cY="\e[1;33m"; cG_="\e[0;32m"; cR_="\e[0;31m"; cB_="\e[0;34m"; cW_="\e[0;37m"; cY_="\e[0;33m"; cZ="\e[0m"; export cR cG cB cY cW cR_ cG_ cB_ cY_ cW_ cZ; }
for tool in rm rmdir dirname readlink file tempfile grep tee git date make gcc wget tar md5sum sed autoconf autoheader; do type $tool > /dev/null 2>&1 || { echo -e "${cR}ERROR:${cZ} couldn't find '$tool' which is required by this script."; exit 1; }; done
pushd $(dirname $0) > /dev/null; CURRABSPATH=$(readlink -nf "$(pwd)"); popd > /dev/null; # Get the directory in which the script resides
( [[ -n "$DEBUG" ]] || [[ -n "$DBG" ]] ) && { DBGCONFIGURE="$SHELL -x "; set -x; }
MEANDMYSELF=${0##*/}
ZLIBURL="http://zlib.net/zlib-1.2.8.tar.gz"
ZLIBMD5="44d667c142d7cda120332623eab69f40"
DROPBEAR_RELEASE="DROPBEAR_2016.74"
INSTALL_TO=${INSTALL_TO:-$HOME/bin/dropbear}
BASEDIR="${BASEDIR:-$(pwd)}"
CACHEDIR="$BASEDIR/cache"

function show_help
{
	echo -e "Syntax: $MEANDMYSELF [-h|-?] [-i <install-dir>] [-v] [-V <dropbear-release-tag>]"
	echo -e "\t${cW}-h | -?${cZ}"
	echo -e "\t  Show this help"
	echo -e "\t${cW}-i${cZ} <install-dir>"
	echo -e "\t  Set the installation directory. Can also be done by setting ${cW}INSTALL_TO${cZ}."
	echo -e "\t${cW}-v${cZ}"
	echo -e "\t  Be verbose about the actions (lines get leading '${cB}[DBG]${cZ}' string)."
	echo -e "\t${cW}-V${cZ} <dropbear-release-tag> ${cY}(if not given defaults to: $DROPBEAR_RELEASE)${cZ}"
	echo -e "\t  Tag to build instead of hardcoded default."
	echo ""
}

function prepare_src
{
	local PRJNAME=${1%%:*}
	local GITCLONE=${1#*:}
	local GITREF=$2
	local PRJ=$(echo "${PRJNAME##*/}"|tr 'a-z' 'A-Z')
	if ((NOCHECKOUT==0)); then
		[[ -d "$CACHEDIR" ]] || mkdir -p "$CACHEDIR"
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Working on project $PRJNAME ($GITCLONE), branch/tag = $GITREF."
		# Clone the repository if we don't have it
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Cloning repository if no clone exists."
		[[ -d "$CACHEDIR/$PRJNAME" ]] || $GITCLONE "$CACHEDIR/$PRJNAME"
		# Sanity check the clone
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Verifying the clone exists now."
		[[ -d "$CACHEDIR/$PRJNAME/.git" ]] || { echo -e "${cR}ERROR:${cZ} apparently we failed to clone $PRJNAME ($GITCLONE)."; exit 1; }
		# Set the Git stuff according to the docs
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Setting branch.master.rebase to true."
		( cd "$CACHEDIR/$PRJNAME" && git config branch.master.rebase true ) || { echo -e "${cR}ERROR:${cZ} could not set 'git config branch.master.rebase true' for $PRJNAME."; exit 1; }
		( cd "$CACHEDIR/$PRJNAME" && echo -en "${cW}$PRJ:${cZ} branch.master.rebase = " && git config --get branch.master.rebase )
		( cd "$CACHEDIR/$PRJNAME" && if [[ "xtrue" == "x$(git config --get core.bare)" ]]; then git config --bool core.bare false; fi ) || { echo -e "${cR}ERROR:${cZ} could not set 'git config --bool core.bare false' for $PRJNAME."; exit 1; }
		((REVIVEPKG)) && ( cd "$CACHEDIR/$PRJNAME" && echo -ne "\tHard-resetting ($(git config --get core.bare)) after thawing it.\n\t-> "; git reset --hard )
		# Scrub the working copy
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Cleaning extraneous files from Git clone."
		( cd "$CACHEDIR/$PRJNAME" && git clean -d -f ) || { echo -e "${cR}ERROR:${cZ} failed to 'git clean' $PRJNAME."; exit 1; }
		# Get latest changes to the Git repo
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Fetching updates from upstream."
		( cd "$CACHEDIR/$PRJNAME" && git fetch ) || { echo -e "${cY}WARNING:${cZ} failed to 'git fetch' $PRJNAME."; }
		# Check out the release
		((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Checking out the files on current branch."
		( cd "$CACHEDIR/$PRJNAME" && echo -en "${cW}$PRJ:${cZ} " && git checkout $GITREF ) || { echo -e "${cR}ERROR:${cZ} failed to check out $GITREF for $PRJNAME."; exit 1; }
		if git --git-dir="$CACHEDIR/$PRJNAME/.git" rev-parse --symbolic --branches|grep -q "$GITREF"; then
			((VERBOSE)) && echo -e "${cB}[DBG:$PRJ]${cZ} Fast-forwarding, if possible."
			( cd "$CACHEDIR/$PRJNAME" && echo -en "${cW}$PRJ:${cZ} " && git merge --ff-only origin/$GITREF ) || { echo -e "${cR}ERROR:${cZ} failed to fast-forward to origin/$GITREF for $PRJNAME."; exit 1; }
		fi
		((GARBAGECOLLECT)) && ( echo "Now garbage-collecting the repository${GCAGGRESSIVE:+ ($GCAGGRESSIVE)}"; cd "$CACHEDIR/$PRJNAME" && git gc $GCAGGRESSIVE --prune=all)
	fi
	((ONLYCHECKOUT)) && return
}

function show_time_diff
{
	local START=$1
	local END=$2
	local MSG=$3
	[[ -n "$MSG" ]] || MSG="Runtime: %s"
	local DIFF=$((END-START))
	local DIFF_MIN=$((DIFF/60))
	local DIFF_SEC=$((DIFF%60))
	printf "$MSG\n" $(printf "%d:%02d" "$DIFF_MIN" "$DIFF_SEC")
}

[[ "$1" == "--help" ]] && { show_help; exit 0; }
while getopts "h?i:vV:" opt; do
	case "$opt" in
	h|\?)
		show_help
		exit 0
		;;
	i)  [[ -n "$OPTARG" ]] || { echo -e "${cR}ERROR:${cZ} ${cY}-$opt${cZ} requires an argument." >&2; exit 1; }
		INSTALL_TO="$OPTARG"
		;;
	v)  VERBOSE=1
		((VERBOSE)) && echo -e "${cB}[DBG]${cZ} Enabling verbose run."
		;;
	V)  [[ -n "$OPTARG" ]] || { echo -e "${cR}ERROR:${cZ} ${cY}-$opt${cZ} requires an argument." >&2; exit 1; }
		MUSLLIBC_RELEASE="$OPTARG"
		;;
	*)
		echo -e "${cY}WARNING:${cZ} unknown option '$opt'"
		;;
	esac
done
echo -e "Working directory: $BASEDIR"
let PM=$(grep -c processor /proc/cpuinfo)
((VERBOSE)) && echo -e "${cB}[DBG]${cZ} Number of parallel jobs, based on processor count: $PM."
let TIME_START=$(date +%s)
PRJNAME="dropbear"
PRJSRCDIR="$CACHEDIR/$PRJNAME"
BUILDDIR="${PRJSRCDIR}.build"
((VERBOSE)) && echo -e "${cB}[DBG]${cZ} Preparing $PRJNAME"
prepare_src "$PRJNAME:git clone https://github.com/mkj/dropbear.git" "$DROPBEAR_RELEASE"

# Build musl-libc if not yet available
MUSLGCC="$HOME/bin/musl/musl-gcc"
if type "$MUSLGCC" > /dev/null 2>&1; then
	( echo -e "${cW}${MUSLGCC##*/} already exists${cZ}" )
else
	( echo -e "${cW}Building ${MUSLGCC##*/} now${cZ}"; cd "$CURRABSPATH" && ./build-musl )
fi
PATH=${MUSLGCC%/*}:$PATH
SRCTARBALLDIR="$CACHEDIR/source-tarballs"
[[ -d "$SRCTARBALLDIR" ]] || mkdir -p "$SRCTARBALLDIR"
ZLIBPKG="$SRCTARBALLDIR/${ZLIBURL##*/}"
if [[ -f "$ZLIBPKG" ]]; then
	echo -e "${cW}${ZLIBURL##*/} already downloaded, using cached copy${cZ}"
else
	wget -nc -O "$ZLIBPKG" "$ZLIBURL" || curl -o "$ZLIBPKG" "$ZLIBURL" || { echo -e "${cR}ERROR:${cZ} failed to download $ZLIBURL"; exit 1; }
fi
echo "$ZLIBMD5  $ZLIBPKG"|md5sum -c ||  { echo -e "${cR}ERROR:${cZ} MD5 hash does not match!"; exit 1; }
( rm -rf "$BUILDDIR"; mkdir -p "$BUILDDIR/zlib" )
if echo -n "... unpacking zlib" && tar --strip-components=1 -C "$BUILDDIR/zlib" -xf "$ZLIBPKG" && mkdir -p "$BUILDDIR/zlib/tempinstall"; then
	echo -e " ${cG}[OK]${cZ}"
else
	echo -e " ${cR}[failed]${cZ}"
	exit 1
fi
# Configure GCC for our purpose
export CC="musl-gcc"
export LDFLAGS="-Wl,--gc-sections"
export CFLAGS="-ffunction-sections -fdata-sections"
# proceed ...
echo -e "Configuring and building ${cW}zlib${cZ}"
(
	cd "$BUILDDIR/zlib" && \
		./configure --static "--prefix=$BUILDDIR/zlib/tempinstall" && \
		make -j 8 && \
		make install
) || { echo -e "${cR}ERROR:${cZ} zlib failed to build."; exit 1; }
echo -e "Configuring and building ${cW}dropbear${cZ}"
(
	cd "$PRJSRCDIR" && \
		autoconf && autoheader && \
	cd "$BUILDDIR" && \
		$PRJSRCDIR/configure "--with-zlib=$BUILDDIR/zlib/tempinstall" --disable-syslog --disable-lastlog --without-pam --enable-bundled-libtom && \
		make -j8 PROGRAMS="dropbear dbclient scp dropbearkey dropbearconvert" MULTI=1 STATIC=1 SCPPROGRESS=1 strip && \
		DBVER=$(./dropbearmulti 2>&1|grep -oE 'v[[:digit:]]+\.[[:digit:]]+'||echo -n 'unknown')
		tar -czvf "$CURRABSPATH/dropbear-$DBVER-static.tgz" $(find -maxdepth 1 -type l) dropbearmulti
) || { echo -e "${cR}ERROR:${cZ} dropbear failed to build."; exit 1; }






exit 0
		sed -i 's|ifdef SO_PRIORITY|#ifdef SO_PRIORITY\n#undef SO_PRIORITY\n#endif\nif 0|g' $PRJSRCDIR/includes.h && \
